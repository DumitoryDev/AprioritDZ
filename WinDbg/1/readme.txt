1. Открыл WinDbg и настроил символы (SRV*C:\Symbols*http://msdl.microsoft.com/download/symbols)
2. Скачал программу ProcDump для создания дампов(её рекомендуют использовать)
3. Сделал дамп приложения в момент крэша(команда - procdump.exe -ma -l -o -e 1 -w -x . "CrashApp.exe")
4. Открыл в WinDbg дамп, выполнил команду !analyze -v
5. Увидел исключение std::_Xout_of_range.

6. Запустил программу, посмотрел, как она работает. Увидел, что кидается несколько исключений, начиная с std::_Xout_of_range. С помощью OllyDbg  прошелся по коду(удобнее), увидел, что после получения аргументов командной вызывается функция, где кидается исключение std::_Xout_of_range с текстом "invalid vector<T> subcript", но, вроде, никакого вектора не создается. Предполгаю, что кидается исключение просто так. После того, как исключение брошено, происходят некоторые действия, но по итогу мы общаемся с нулевому указателю. (всё это случается с последущим вызовом RaiseException, после std::_Xout_of_range). Предполгаю, что исключение просто не обрабатывается.

7. Проделал тоже самое с x64 версией приложения. Картина почти та же, но после выполнения !analyze -v в момент обращения по нулевому указателю, меня привлекла строка X64_APPLICATION_FAULT_INVALID_POINTER_READ_vcruntime140!__std_exception_copy+30. Что подтверждает мою теорию о том, что исключение было просто не обработано.

5. Предполагаю, что приложение упало в следствии необработанного исключения std::_Xout_of_range. Скорее всего, исключение бросается сразу после старта программы.


P.S Я прав? Уж больно интересно, действительно мои исследования оказались верными.))

